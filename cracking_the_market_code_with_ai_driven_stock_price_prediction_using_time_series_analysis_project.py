# -*- coding: utf-8 -*-
"""Cracking the market code with AI-driven stock price prediction using time series analysis project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WSeOuCjfsV5Yg8cEvrkDRuwkjAlSRoIP
"""

! pip install ta gradio

# üì¶ COMMAND 2: Import libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objects as go
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error
from math import sqrt
import ta
import gradio as gr
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

df = pd.read_csv('https://github.com/batman1503/Cracking-the-market-code-with-AI-driven-stock-price-prediction-using-time-series-analysis-project/raw/main/tesla-stock-price.csv')
df.head()

df.info()

# üßπ COMMAND 4: Preprocessing
# Convert date
df['date'] = pd.to_datetime(df['date'])
df.set_index('date', inplace=True)

df['volume'] = df['volume'].str.replace(',', '', regex=False)
df['volume'] = pd.to_numeric(df['volume'], errors='coerce')

# Sort values
df.sort_index(inplace=True)

# Drop nulls and check structure
df.dropna(inplace=True)

# üìä COMMAND 5: EDA - Visualizing price trends
plt.figure(figsize=(14, 6))
plt.plot(df['close'], label='Close Price')
plt.title('Tesla Closing Price Over Time')
plt.xlabel('Date')
plt.ylabel('Price ($)')
plt.legend()
plt.grid(True)
plt.show()

# üìä COMMAND 6: EDA - Correlation heatmap
plt.figure(figsize=(10, 6))
sns.heatmap(df.corr(), annot=True, cmap='coolwarm')
plt.title('Feature Correlation')
plt.show()

# üß† COMMAND 7: Feature Engineering - Add technical indicators
df['SMA_10'] = ta.trend.sma_indicator(df['close'], window=10)
df['SMA_30'] = ta.trend.sma_indicator(df['close'], window=30)
df['RSI'] = ta.momentum.rsi(df['close'], window=14)
df['MACD'] = ta.trend.macd_diff(df['close'])
df['BB_upper'], df['BB_middle'], df['BB_lower'] = ta.volatility.BollingerBands(df['close']).bollinger_hband(), ta.volatility.BollingerBands(df['close']).bollinger_mavg(), ta.volatility.BollingerBands(df['close']).bollinger_lband()

# Drop rows with NA from indicators
df.dropna(inplace=True)

# ‚öôÔ∏è COMMAND 8: Prepare data for LSTM
features = df.index
target = 'Close'

scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(df[features])

sequence_length = 60
X, y = [], []

for i in range(sequence_length, len(scaled_data)):
    X.append(scaled_data[i-sequence_length:i])
    y.append(scaled_data[i][0])  # Close price

X, y = np.array(X), np.array(y)

# Chronological split (80/20)
split = int(0.8 * len(X))
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

# ü§ñ COMMAND 9: Build the LSTM model
model = Sequential([
    LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])),
    Dropout(0.2),
    LSTM(50),
    Dropout(0.2),
    Dense(1)
])

model.compile(optimizer='adam', loss='mean_squared_error')
model.summary()

# üìà COMMAND 11: Evaluate the model
predicted = model.predict(X_test)
predicted_price = scaler.inverse_transform(np.concatenate((predicted, X_test[:, -1, 1:]), axis=1))[:, 0]
real_price = scaler.inverse_transform(np.concatenate((y_test.reshape(-1, 1), X_test[:, -1, 1:]), axis=1))[:, 0]

rmse = sqrt(mean_squared_error(real_price, predicted_price))
mae = mean_absolute_error(real_price, predicted_price)

print(f'RMSE: {rmse:.2f}')
print(f'MAE: {mae:.2f}')

# üìâ COMMAND 12: Visualization of predictions
plt.figure(figsize=(14,6))
plt.plot(real_price, label='Actual Price')
plt.plot(predicted_price, label='Predicted Price')
plt.title('LSTM Model - Actual vs Predicted Prices')
plt.xlabel('Time')
plt.ylabel('Price ($)')
plt.legend()
plt.grid(True)
plt.show()

!pip install cartopy
import cartopy

# https://pypi.python.org/pypi/pydot
!apt-get -qq install -y graphviz && pip install pydot
import pydot

!pip install gradio  # Re-install gradio
import gradio as gr  # Then import it

# üöÄ COMMAND 13: Gradio App Deployment
def predict_price(input_seq):
    seq = scaler.transform(np.array(input_seq).reshape(-1, len(features)))
    X_input = np.array([seq[-sequence_length:]])
    pred = model.predict(X_input)
    pred_price = scaler.inverse_transform(np.concatenate((pred, X_input[:, -1, 1:]), axis=1))[0][0]
    return f"Predicted Price: ${pred_price:.2f}"

inputs = [gr.Textbox(label=f'Input past {sequence_length} days - {features} (comma-separated values)')]

demo = gr.Interface(fn=predict_price,
                    inputs="text",
                    outputs="text",
                    title="Tesla Stock Price Predictor",
                    description="Enter the most recent values for the features to predict the next day's price.")

demo.launch()